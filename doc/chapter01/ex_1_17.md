# [Глава 1](../index.md#Глава-1-Построение-абстракций-с-помощью-процедур)

### Упражнение 1.17
Алгоритмы возведения в степень из этого раздела основаны на повторяющемся умножении. Подобным же образом можно производить умножение с помощью повторяющегося сложения. Следующая процедура умножения (в которой предполагается, что наш язык способен только складывать, но не умножать) аналогична процедуре `expt`:

```clojure
(defn * [a b]
  (if (zero? b)
    0
    (+ a
       (* a
          (dec b)))))
```

Этот алгоритм затрачивает количество шагов, линейно пропорциональное _b_. Предположим теперь, что, наряду со сложением, у нас есть операции `double`, которая удваивает целое число, и `halve`, которая делит (четное) число на 2. Используя их, напишите процедуру, аналогичную `fast-expt`, которая затрачивает логарифмическое число шагов.

#### Решение
[Code](../src/sicp/chapter01/1_17.clj) | [Test](../test/sicp/chapter01/1_17_test.clj)
